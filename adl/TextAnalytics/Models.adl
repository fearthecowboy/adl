/// NOTES: 1500 lines of JSON models distilled down to 440 lines of text (including Enums, and not inlcluding extra line breaks)


model JobDescriptor {
  /// Optional display name for the analysis job.  
  displayName: string;
}

/// Contains a set of input documents to be analyzed by the service.
model MultiLanguageBatchInput {
  /// The set of documents to process as part of this batch.
  documents: Array<MultiLanguageInput>;
}

/// Contains an input document to be analyzed by the service.
model MultiLanguageInput {
  /// A unique, non-empty document identifier
  id: string;

  /// The input text to process.
  text: string;

  /// (Optional) This is the 2 letter ISO 639-1 representation of a language. For example, use \"en\" for English; \"es\" for Spanish etc. If not set, use \"en\" for English as default
  language: @optional string; 
}

model EntitiesTaskParameters {
  modelVersion: @optional @name('model-version') @default('latest') string;
  stringIndexType: @optional StringIndexType;
}

model EntitiesTask {
  parameters: @optional EntitiesTaskParameters;
}

model PiiTaskParameters {
  domain: "phi" | "none";
  modelVersion: @optional @name('model-version') @default('latest') string;
  stringIndexType: @optional StringIndexType;
}

model PiiTask {
  parameters: @optional PiiTaskParameters;
}

model KeyPhrasesTaskParameters {
   modelVersion: @optional @name('model-version') @default('latest') string;  
}

model KeyPhrasesTask {
  parameters: @optional KeyPhrasesTaskParameters;
}

model JobTasks {
    entityRecognitonTasks: @optional Array<EntitiesTask>;

    entityRecognitionPiiTasks: @optional Array<PiiTask>;

    keyPhraseExtractionTasks: @optional Array<KeyPhrasesTask>;
}

model JobManifest {
  /// The set of tasks to execute on the input documents. Cannot specify the same task more than once.
  tasks: JobTasks;
}

model AnalyzeBatchInput : JobDescriptor, JobManifest {
  analysisInput: MultiLanguageBatchInput;
}

model Pagination {
  nextlink: url;
}

model TaskState {
  name: string;
  status: State;
  lastUpdateDateTime: dateTime;
}

model JobMetadata {
  createdDateTime: dateTime;
  displayName: @optional string;
  expirationDateTime: @optional dateTime;
  jobId: uuid;
  lastUpdateDateTime: dateTime;
  status: State;
}

/// if showStats=true was specified in the request this field will contain information about the document payload
model DocumentStatistics {

  /// Number of text elements recognized in the document
  charactersCount: int32;

  /// Number of transactions for the document
  transactionsCount: int32;
}

model DocumentEntities {
  /// Unique, non-empty document identifier.
  id: string;

  /// Recognized entities in the document
  entities: Array<Entity>;

  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional  DocumentStatistics;
}

model DocumentError {
  /// Document ID
  id: string;

  /// Document Error
  error: TextAnalyticsError;
}

model EntitiesResult {
  /// Response by document
  documents: Array<DocumentEntities>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model EntityRecognitionTask : TaskState {
  results: EntitiesResult;
}

model TasksStateTasksDetails {
  details: @optional TaskState;
  completed: int32;
  failed: int32;
  inProgress: int32;
  total: int32;
  entityRecognitionTasks: Array<EntityRecognitionTask>;
}

model TasksStateTasks {
  details: TasksStateTasksDetails;
}

model TasksState {
  tasks: TasksStateTasks;
}

/// if showStats=true was specified in the request this field will contain information about the request payload
model RequestStatistics { 
  /// Number of documents submitted in the request.
  documentsCount: int32;

  /// Number of valid documents. This excludes empty, over-size limit or non-supported languages documents
  validDocumentsCount: int32;

  /// Number of invalid documents. This includes empty, over-size limit or non-supported languages documents
  erroneousDocumentsCount: int32;

  /// Number of transactions for the request
  transactionsCount: int64;
  
}

/// Represents the confidence scores between 0 and 1 across all sentiment classes: positive, neutral, negative
model SentimentConfidenceScorePerLabel {
  positive: double;
  neutral: double;
  negative: double;
}

model SentenceSentiment {
  /// The sentence text
  text: string;
  
  /// The predicted Sentiment for the sentence
  sentiment: SentenceSentimentValue;

  /// The sentiment confidence score between 0 and 1 for the sentence for all classes
  confidenceScores: SentimentConfidenceScorePerLabel;

  /// The sentence offset from the start of the document
  offset: int32;

  /// The length of the sentence
  length: int32;

  /// The array of aspect object for the sentence
  aspects: @optional Array<SentenceAspect>;

  /// The array of opinion object for the sentence.
  opinions: @optional Array<SentenceOpinion>;
}

model SentenceAspect {
  /// Aspect level sentiment for the aspect in the sentence
  sentiment: TokenSentimentValue;

  /// Aspect level sentiment confidence scores for the aspect in the sentence.
  confidenceScores: AspectConfidenceScoreLabel;
    
  /// The aspect offset from the start of the sentence
  offset: int32;

  /// The length of the aspect
  length: int32;

  /// The aspect text detected
  text: string;

  /// The array of either opinion or aspect object which is related to the aspect
  relations: Array<AspectRelation>;
}

model SentenceOpinion {
  /// Opinion level sentiment for the aspect in the sentence
  sentiment: TokenSentimentValue;

  /// Opinion level sentiment confidence scores for the aspect in the sentence.
  confidenceScores: AspectConfidenceScoreLabel;
    
  /// The aspect offset from the start of the sentence
  offset: int32;

  /// The length of the opinion
  length: int32;

  /// The aspect text detected
  text: string;

  /// The indicator representing if the opinion is negated.
  isNegated: boolean;
}

model AspectRelation {
  /// The type related to the aspect
  relationType: AspectRelationType;

  /// The JSON pointer indicating the linked object.
  ref: string;
}

/// Represents the confidence scores across all sentiment classes: positive, neutral, negative
model AspectConfidenceScoreLabel {
  positive: double;
  negative: double;
}
 
model PiiDocumentEntities {
  
  /// Unique, non-empty document identifier
  id: string;
  
  /// Returns redacted text.
  redactedText: string;
  
  /// Recognized entities in the document
  entities: Array<Entity>;
    
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>; 

  /// if showStats=true was specified in the request this field will contain information about the document payload
  statistics: @optional DocumentStatistics;
}

model AnalyzeJobState : JobMetadata, TasksState, Pagination {

  errors: Array<TextAnalyticsError>;

  statistics: RequestStatistics;
}

model Entity {
  
  /// Entity text as appears in the request
  text: string;

  /// Entity type 
  category: string;
  
  /// (Optional) Entity sub type 
  subcategory: @optional string;
  
  /// Start position for the entity text. Use of different 'stringIndexType' values can affect the offset returned 
  offset: int32;
  
  /// Length for the entity text. Use of different 'stringIndexType' values can affect the length returned 
  length: int32;
  
  /// Confidence score between 0 and 1 of the extracted entity 
  confidenceScore: double;
}

model EntityLinkingResult {
  /// Response by document
  documents: Array<DocumentLinkedEntities>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: string;
}

model DocumentLinkedEntities {
  /// Unique, non-empty document identifier
  id: string;

  /// Recognized well-known entities in the document
  entities: Array<LinkedEntity>;

  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional DocumentStatistics;
}

model HealthcareJobState: JobMetadata, Pagination {
  results: HealthcareResult;
  errors: Array<TextAnalyticsError>;
}

model HealthcareResult {
  /// Response by document
  documents: Array<DocumentHealthcareEntities>;
  errors: Array<DocumentError>;
  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring
  modelVersion: string;
}

model DocumentHealthcareEntities { 

  /// Unique, non-empty document identifier
  id: string;

  /// Healthcare entities
  entities: Array<HealthcareEntity>;
  
  /// Healthcare entity relations
  relations: Array<HealthcareRelation>;
  
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload
  statistics: @optional DocumentStatistics;
}

model HealthcareEntity : Entity{
  isNegated: boolean;

  /// Entity references in known data sources
  links: Array<HealthcareEntityLink>;
}

model HealthcareRelation {
  /// Type of relation. Examples include: `DosageOfMedication` or 'FrequencyOfMedication', etc
  relationType: string;
 
  /// If true the relation between the entities is bidirectional, otherwise directionality is source to target
  bidirectional: boolean;
 
  /// Reference link to the source entity
  source: string;
 
  /// Reference link to the target entity
  target: string;
 
}
 

model HealthcareEntityLink {
  /// Entity Catalog. Examples include: UMLS, CHV, MSH, etc.
  dataSource: string;

  /// Entity id in the given source catalog.
  id: string;

}

model LinkedEntity {
  /// Entity Linking formal name
  name: string;

  /// List of instances this entity appears in the text
  matches: Array<Match>;

  /// Language used in the data source
  language: string;

  /// Unique identifier of the recognized entity from the data source
  id: string;

  /// URL for the entity's page from the data source
  url: string;

  /// Data source used to extract entity linking, such as Wiki/Bing etc
  dataSource: string;

  /// Bing Entity Search API unique identifier of the recognized entity
  bingId: string;
}

model Match { 
  /// If a well-known item is recognized, a decimal number denoting the confidence level between 0 and 1 will be returned
  confidenceScore: double;
    
  /// Entity text as appears in the request
  text: string;
    
  /// Start position for the entity match text
  offset: int32;
    
  /// Length for the entity match text
  length: int32;
}

model KeyPhraseResult {
  /// Response by document
  documents: Array<DocumentKeyPhrases>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model DocumentKeyPhrases {
  /// Unique, non-empty document identifier
  id: string;
 
  /// A list of representative words or phrases. The number of key phrases returned is proportional to the number of words in the input document
  keyPhrases: Array<string>;
  
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional DocumentStatistics;
}

model LanguageBatchInput {
  documents: Array<LanguageInput>;
}

model LanguageInput {
  /// Unique, non-empty document identifier
  id: string;

  text: string;
  countryHint: @optional string;
}

model PiiResult {
  /// Response by document
  documents: Array<PiiDocumentEntities>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model LanguageResult {
  /// Response by document
  documents: Array<DocumentLanguage>;

  /// Errors by document id.
  errors: Array<DocumentError>;

  statistics: @optional RequestStatistics;

  /// This field indicates which model is used for scoring.
  modelVersion: @name('model-version') @default('latest') string;
}

model DocumentLanguage {
  /// Unique, non-empty document identifier
  id: string;
 
  /// Detected Language
  detectedLanguage: detectedLanguage;
  
  /// Warnings encountered while processing document
  warnings: Array<TextAnalyticsWarning>;

  /// if showStats=true was specified in the request this field will contain information about the document payload.
  statistics: @optional DocumentStatistics;
}

model DetectedLanguage {
  /// Long name of a detected language (e.g. English, French)
  name: string;

  /// A two letter representation of the detected language according to the ISO 639-1 standard (e.g. en, fr)
  iso6391Name: string;

  /// A confidence score between 0 and 1. Scores close to 1 indicate 100% certainty that the identified language is true
  confidenceScore: double;

}
